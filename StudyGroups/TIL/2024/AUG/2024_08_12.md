# 문제: 멀리뛰기
https://school.programmers.co.kr/learn/courses/30/lessons/12914

- 목표 지점에 갈 때 1칸이나 2칸 뛸 수 있음
- 목표 지점으로 갈 수 있는 경우의 수 구하기 % 1234567

## 아이디어
- 뛸 수 있는 건 1칸이나 2칸이기 때문에 n번째 도착하는 것은 n-1번째 도착하는 가지수와 n-2 자리에 도착하는 가지수의 합이다.
- 왜냐하면 n-1 칸에서는 n번째 칸에 갈 수 있는 방법이 1가지(1칸 점프)이고, n-2 칸에서도 n번째 칸에 갈 수 있는 방법이 1가지(2칸 점프)이기 때문이다.
- 그래서 풀고 나면 피보나치 수열과 같아진다.
- 처음에는 1칸, 2칸씩 움직이는 포인터를 써야 하나 싶었는데 문제를 읽다보니까 이전 결과로 다음 결과을 구할 때 사용하는 DP문제였다.

## 풀이
1. 0과 1일 때 케이스를 저장해둔다. (i-2 인덱스 에러가 나지 않기 위해)
2. n이 1 초과면 이전 2 스텝의 결과를 더해서 값을 구한다.
```python
def solution(n):
    memo = {}
    memo[0] = 1
    memo[1] = 1
    
    if n > 1:
        for i in range(2, n+1):
            memo[i] = memo[i-1] + memo[i-2]
        
    return memo[n] % 1234567
```

다른 풀이
```python
def jumpCase(num):
    a, b = 0, 1
    for i in range(1,num):
        a, b = b, a+b
    return b
```

## 배운 점
- DP 문제를 점화식처럼 생각하려고 노력하고 있다.
    - f(n) = 1 * f(n-1) + 1 * f(n-2) 이런 식으로 구조화하면 어떻게 풀지 나오는듯