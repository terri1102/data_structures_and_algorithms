# 문제: 구명보트
https://school.programmers.co.kr/learn/courses/30/lessons/42885

## 아이디어
- 투 포인터
1. 정렬
2. 맨 앞과 맨 뒤를 포인터 2개로 가리킴
3. 포인터 2개가 가리키는 무게를 더해서 limit 아래 인지 확인
4-1. limit 이상이면 뒤쪽 사람만 탈 수 있기 때문에 2번 포인터를 removed_index에 추가하고, 2번 포인터를 한 칸 앞으로 이동하고, boat += 1.

4-2. limit 보다 작으면 포인터 2개가 가리키는 사람 2명이 탈 수 있기 때문에 removed_index에 둘다 넣고, 1번 포인터는 한 칸 뒤로 2번 포인터는 한 칸 뒤로 이동하고, boat += 1.

## 풀이
내 풀이
```python
def solution(people, limit):
    ptr1, ptr2 = 0, len(people) - 1
    boat = 0
    people.sort()
    removed_index = []
    while len(removed_index) < len(people):
        if people[ptr1] + people[ptr2] <= limit:
            boat += 1
            removed_index.append(ptr1)
            removed_index.append(ptr2)
            ptr1 += 1
            ptr2 -= 1
        else:
            boat += 1
            removed_index.append(ptr2)
            ptr2 -= 1
    return boat
```

다른 풀이: 위의 풀이와 매우 흡사하지만 투포인터 방식이지만 좀더 효율적인 풀이 
- ptr2와 ptr1이 만나면 while문을 벗어나며 removed_index라는 추가 리스트를 사용하지 않아서 더 효율적인 것 같다.
- 전체 인원에서 짝지은 수만 빼주면 보트의 수가 나온다.

```python
def solution(people, limit) :
    answer = 0
    people.sort()

    ptr1 = 0
    ptr2 = len(people) - 1
    while ptr1 < ptr2 :
        if people[ptr2] + people[ptr1] <= limit :
            ptr1 += 1
            answer += 1
        ptr2 -= 1
    return len(people) - answer
```

## 배운 점
- 그리디 알고리즘 카테고리라고 했는데 풀다 보니 투 포인터로 풀어서 그리디 알고리즘과 투 포인터의 관계에 대해서 궁금해졌다. 

그리디 알고리즘은 현재 상황에서 가장 좋아 보이는 선택을 반복적으로 선택하는 방식이다. 이 문제에서는 가장 무거운 사람과 가장 가벼운 사람을 쌍으로 묶는 방법을 사용하면 최적의 해를 찾을 수 있기 때문에 그리디 알고리즘으로 분류되었다.

즉, 이 문제는 그리디 알고리즘에 해당하면서 투포인터 방식으로 풀 수 있는 문제라고 할 수 있다. 그리디 알고리즘하면 생각나는 문제들은 이런 보트에 사람을 나누는 문제들, knapsack 알고리즘 등이 있는데, 이번 기회에 그리디 알고리즘과 투 포인터 문제의 대표 유형에 대해서 살펴봤다.

### [투 포인터로 푸는 유형들]
1. 정렬된 배열에서의 탐색 문제:
- 정렬된 배열에서는 왼쪽 포인터를 시작점에, 오른쪽 포인터를 끝점에 놓고 조건에 따라 포인터를 이동시키며 해결.

    ex) 두 숫자의 합이 특정 값이 되는 쌍 찾기 (Two Sum 문제)

2. 구간 합 문제:
- 포인터를 사용해 구간을 확장하거나 축소하면서 조건을 만족하는 구간을 찾기.

    ex) 부분 배열의 합이 특정 값이 되는 경우 찾기

3. 팰린드롬 문제:
- 문자열의 양 끝에서 시작해 가운데로 이동하면서 문자를 비교.

    ex) 문자열이 회문인지 확인

4. 슬라이딩 윈도우 문제:
- 윈도우의 시작과 끝을 포인터로 조절하며 최적해를 찾기.

    ex) 고정된 길이 또는 가변 길이의 윈도우에서 최대/최소 값 찾기

5. 이중 배열 문제:
- 각 배열에 하나씩 포인터를 두고 조건에 따라 포인터를 이동시키며 해결.

    ex) 두 정렬된 배열의 공통 원소 찾기

### [그리디 알고리즘 대표 유형들]
1. 최소 신장 트리:
- 그래프에서 모든 노드를 연결하는 최소 비용의 신장 트리를 찾기

    ex) 크루스칼 알고리즘, 프림 알고리즘

2. 최단 경로 문제:
- 가중치가 있는 그래프에서 시작 노드부터 다른 모든 노드까지의 최단 경로를 찾기.

    ex) 다익스트라 알고리즘

3. 활동 선택 문제:
- 겹치지 않는 활동의 최대 집합을 선택.

    ex) 회의실 배정 문제

4. 분할 가능한 배낭 문제:
- 아이템을 쪼갤 수 있을 때, 배낭에 최대 가치를 담는 방법을 찾습니다.

    ex) fractional knapsack problem
