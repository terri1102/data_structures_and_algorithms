# 문제: 큰 수 만들기
https://school.programmers.co.kr/learn/courses/30/lessons/42883

## 아이디어
이 문제는 풀지 못해서 답을 보고 어떻게 이렇게 풀게 되는지에 대해서 생각해봤다.

1. 문제
- 목표: number 문자열에서 k개의 숫자를 제거하여 가장 큰 수를 만든다.
- 조건: 숫자의 순서는 유지된다. 따라서 **정렬할 수 없고,** "스택"이나 큐처럼 순서가 유지되는 구조를 사용할 수 있다.
2. 그리디 알고리즘을 사용하여 해결 방안 모색
- 앞자리부터 최선의 숫자 선택: 가장 큰 숫자를 만들기 위해 앞자리부터 가능한 큰 숫자를 선택해야 한다.
- 숫자 제거 기준: 현재 숫자가 스택의 마지막 숫자보다 크면, 스택의 마지막 숫자를 제거하는 것이 유리하다.
3. 스택을 이용한 그리디 알고리즘 설계
- 스택 사용 이유: 스택을 사용하여 숫자를 관리하면서 필요한 경우 숫자를 쉽게 제거할 수 있다.
- 조건부 제거: 현재 숫자가 스택의 마지막 숫자보다 크면 스택의 숫자를 제거하고 현재 숫자를 추가한다.
- 제거 횟수 관리: k개의 숫자를 제거해야 하므로, 제거할 때마다 k를 감소시킨다.


### 그리디 알고리즘 선택 이유
이 문제가 그리디 알고리즘 카테고리 문제인 이유는 "부분 문제의 최적해가 전체 문제의 최적해로 이어지기 때문"이다. 각 자리에서 가장 큰 숫자를 선택하는 것이 전체 결과에 긍정적인 영향을 미친다.
또한, 현재 상태에서 가장 큰 숫자를 선택하면, 전체적으로 가장 큰 숫자를 만들 수 있다.


## 풀이
1. 각 숫자를 차례로 순회한다.
2. 현재 숫자와 스택의 마지막 숫자를 비교한다.

   2-1. 현재 숫자가 스택의 마지막 숫자보다 크면, 스택의 마지막 숫자를 제거한다. (이렇게 하면 더 큰 숫자를 앞으로 오게 할 수 있다)
숫자를 제거할 때마다 k를 감소시킨다.

    **while**을 사용해서 한번에 스택의 여러 요소를 제거하게 한다.

    2-2. 숫자를 제거하지 않는다.

3. 현재 숫자를 스택에 추가한다.

4. 모든 숫자를 처리한 후에도 k가 남아있다면, 스택의 뒤에서부터 남은 k개의 숫자를 제거한다.
최종적으로 스택에 남은 숫자들을 문자열로 변환하여 반환한다.

ex) "1231234"

| num | 조건 해당 여부 | answer | k |
| :--: | :--: | :--: |  :--: |
| 1 | x | [1] | 3 |
| 2 | o | [2] | 2 |
| 3 | o | [3] | 1 |
| 1 | x | [3,1] | 1 |
| 2 | o | [3,2] | 0 |
| 3 | x | [3,2,3]| 0 |
| 4 | x | [3,2,3,4]|0 |

-> answer[:4-0] = [3,2,3,4]


ex) "4177252841"

| num | 조건 해당 여부 | answer | k |
| :--: | :--: | :--: |  :--: |
| 4 | x | [4] | 4 |
| 1 | x | [4,1] | 4 |
| 7 | o | [7] | 2 |
| 7 | x | [7,7] | 2 |
| 2 | x | [7,7,2] | 2 |
| 5 | o | [7,7,5]| 1 |
| 2 | x | [7,7,5,2]|1 |
| 8 | o | [7,7,5,8] |0 |
| 4 | x | [7,7,5,8,4]|0 |
| 1 | x | [7,7,5,8,4,1]|0 |

- "".join(answer[:len(answer)-k])
- len(answer) = 6
- k=0
- answer[:6] =  [7,7,5,8,4,1]

```python
def solution(number, k):
    answer = [] 
    for num in number:
        while k > 0 and answer and answer[-1] < num:
            answer.pop()
            k -= 1 
        answer.append(num)
    return "".join(answer[:len(answer)-k])
```
## 배운 점
- 그리디 알고리즘이 적합한 문제 유형에 대해 알아봤다.
- 순서를 유지하면서 k개의 요소를 제거해서 가장 큰 숫자를 만들 때, 스택의 맨 뒤 요소와 새로운 요소만 비교하면 된다는 것을 알게되었다.